title: "Turn anything into an ng-model with ngModelController"
date: "23/04/2015"
body: |

  Few people realise that `ng-model` can be turn literally any interative component into a fully-working Angular form field - saving you a heap of work.

  How? By writing a directive that collaborates with `ng-model` via its controller - the `ngModelController`.

  As an example - we'll plug a non-Angular SVG clock into `ng-model`:

  <a class="jsbin-embed" href="http://jsbin.com/nelucu/6/embed?output&height=500">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

  Here's the source to the form:
  

      <form name=timeForm>

        <svg width=1000 height=1000>

          <!-- here we bind our clock to item.time -->
          <g clock-input 
             ng-model=item.time 
             name=time>
          </g>

          <!-- view the value of our input  -->
          <text x=500 y=500>
            {{ item.time | date:"shortTime" }}
          </text>
          <text x=500 y=550 ng-click="toggle()">
            {{ ticking ? "Stop" : "Start" }}
          </text>

        </svg>

      </form>

  The steps we'll need to go through are:

  1. create a directive to intantiate our clock widget - `clock-input`
  1. access the controller of the `ng-model` within our directive
  1. implement two-way binding with our widget via the controller's API

  Step 1 is nothing special - we've got a `donutClock()` widget to instantiate, so let's write a wrapper directive:

      module.directive("clock-input", function clock() {
        return {
          require: "ngModel",
          link: function(scope, el, attrs) {

            // initialize the non-angular widget, and
            // pass in our model updating function
            var clock = donutClock({
              onInput: view2model,
              el: el[0],
            });

            function view2model() {
              // placeholder
            }

          }
        }
      });

  `ngModelController` is the important API here. It's the object representation of an input's logical state. Hooking into `ngModelController` enables our `clock-input` to control the `ng-model` directive, and thus appear as a input on our form.

  To get at the controller instance for our `ng-model`, we request it in our directive definition via the `require:` key. Without a prefix, it'll ensure an instance of directive is present on the same element, and pass its controller to our linking function.

      module.directive("clock-input", function clock() {
        return {
          require: "ngModel",
          /* ngModel instance passed as forth param to link */
          link: function(scope, el, attrs, ngModel) {
          // ...

  We've two jobs in the linking function. We want to get view values into the model, and updated model values into the view.

  We inform the controller of updated time values from the widget via `ngModel.$setViewValue()`. This'll update the model after it's been parsed and validated, and update the form object's state variables.

  To tell Angular how to send updates from the model side to the view we override `ngModel.$render`, which is called when a change is detected to the model:

      link: function(scope, el, attrs, ngModel) {

        // initialize the non-angular widget, and
        // pass in our model updating function
        var clock = donutClock({
          onInput: view2model,
          el: el[0],
        });

        function view2model(value) {
          ngModel.$setViewValue(value);
        }

        // when angular detects a change to the model,
        // we update our widget
        ngModel.$render = function model2view(time) {
          clock.set(ngModel.$viewValue);
        }

      }

  That's it.

  You can do lots more with `ngModelController` - adding validators to the `$validators` object, changing how the values are parsed from the view, or formatted for it, with the `$parsers` and `$formatters` arrays - but that's a story for another blog post.

  I really like this API! One API to turn anything - D3 visualisations, random non-Angular widgets, `<canvas>`, the audio input or accelarometer - into an ng-model. A great example of a well designed abstraction promoting reuse.



  
