title: "BB testing for beginners"
date: "23/04/2012"
body: |  ## 
 
   Testing is writing code to test code, rather than perfoming manual tests (a zombie like processes of click click click, refresh). This has all the benefits you might expect - it's fast, automatable, and doesn't get bored.
   
   If you're new to testing, this article will get you up to speed with the tools, core idea of testing, the types of tests, a bit of the jargon, and the overall ideas of testing.

   ## Tools
 
   You'll need a test runner. There are a heap of of them out there. I prefer those with command line runners, as they're easy to run from within an editor without mousing about - or trigger automatically on a build server. Here's a non-exhaustive list. My examples are in JSTestDriver, but test drivers are all extremely simple - don't worry if you'd prefer to use something else.
 
   - [JSTestDriver]()
   - [Buster.js]
   - [QUnit.js]
   - [DOH]
   - [YETI]
 
   I'm using JSTestDriver for my testing. It's great, so are the above, use whichever you prefer!
   
   ## The very basics of testing
   
   Testing works by making assertions about the behaviour of code. Assertions are functions you call to make certain your code has done certain things. They look like this:
     
   ```
     assertEquals("happy",state)
     assertMatches(/^(\w+)_state/,state)
     assertEmpty(form.errors())
   ```
   
   Every [test](/testing-glossary#test), or [example](/testing-glossary#example), in your code will have one or more [assertion](/testing-glossary#assertion)s. Test one thing in each example - you may want to use multiple assertions to do this, but just ensure they link to the test name.
   
   I personally name tests in a sentence style:
     
   ```
     "it should play a sound on load": function(){
       /* ... */
     },
     "it returns a formatted currency string": function(){
       /* ... */
     }
   ```
   
   You might prefer another style of testing naming. Do whatever you find easiest - but do remember to write tests that describe what your code [_should be doing_](/testing-concepts#behaviour-not-implementation), not _how it is doing it_. We'll return to this later - for now, just remember to write tests that describe behaviours your code needs to exhibit, not the way you've made it do it.
   
   ## The two major types of test
   
   There are two broad categories of tests: unit tests, and functional tests.
 
   ### Unit tests
 
   Unit tests work on piece of code in isolation - often single functions. JS programs are composed of functions and objects that hold functions and variables. Unit tests will take a single function or object and check that it behaves correctly.
 
   Let's look at an example - some real Backbone view code. Let's say we have a view that we'd like to update a model on a click.
 
   ```js
     toggleReminder: function (evt) {
       this.model.set({reminder: !this.model.get("reminder")})
     }
   ```
 
   A very simple case - we'd like this event handle to toggle a reminder. The desired behaviour here is "take a click, and toggle our model's reminder". How could we test that?
 
   ```js
     "it should toggle reminder on click": function() {
       view = makeView()
       assertEquals(false,view.model.get("reminder"))
       view.toggleReminder()
       assertEquals(true,view.model.get("reminder"))
       view.toggleReminder()
       assertEquals(false,view.model.get("reminder"))
     }
   ```
 
   In this simple test we've:
 
   - setup the expected precondition - the state we're basing our reasoning about later expectations upon
   - specified what we expect to happen as a result of triggering behaviour
   - trigger that behaviour (firing the callback to toggle the reminder on and off)
 
   What we haven't done is totally isolate the view from the rest of the system. We're relying on the rest to do it's job - what we're interested is _this_ view's behaviour. A fully unit tested system should work cleanly together - each part rlying on the contract documented through tests. We'll discuss how far to go with isolation in the article on Unit Testing with Mocks and Stubs.
   
   #### Summary
 
   - unit tests are the smallest tests
   - they test one piece of behaviour in isolation
   - they often involve stubbing complex/slow external systems (AJAX, databases like IndexedDB)
   
   ### Functional/integration testing
 
   Functional tests are the opposite of unit tests. They test systems in circumstances as close to reality as possible. They're also normally tests of behaviours users would understand - "when I click this button, this happens", not "this function takes a state object and a method and updates that state".
 
   Functional testing Backbone is more involved than unit testing. I'd argue, however, that it's possible more valuable. You get a lot of testing done in one functional test, covering a lot of code. It'll involve a bit of setup so I'll leave code examples for later, but they'll have names like
 
   "when the user hits the 'buy' button, they see the product appear in their shopping cart"
   "when the user receives a message, they see an alert"
 
   These behaviours involve many components behind the scence - in the first, a view for the buy button, some model procedure to ask the server if it's in stock, and another view that renders the updated cart. Simple behaviour for the user - lots of code to be tested.
 
   They're also known as integration tests as they test components working together. You could have a integration test that wasn't a functional test - plumbing code between your model and persistance layer for instance. Don't get too het up about the names - Rails integration tests are functional tests.
 
   #### Summary
 
   - functional tests test the system as close to 'for real' as possible
   - they work on testing user-recognisable behaviour
   - they're great for testing a lot of code quickly
 
   ## Key testing ideas