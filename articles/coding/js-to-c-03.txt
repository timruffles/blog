title: "Architecture for a JS to C compiler"
date: "2018/12/31"
body: |

  The basic data-flow of compilation looks like this:

  1. parse
  1. optimisation (optional)
  1. code generation

  My JS to C compiler will implement this as follows

  1. parse: rely on esprima - this project is about compilation not parsing
  1. code generation + optimisation: a compiler written in TypeScript, outputting C code

  We'll also need a runtime. There is a lot of runtime behaviour in JS that cannot be implemented without runtime support. This I'll write directly in C. For instance garbage collection must be provided by the host environment.

  Our flow will be  

  1. parse: `esprima`
  1. compiler: `js-to-c.ts`
  1. run: `js-to-c.dylib`

  ## C as a target language
  
  C is lower-level than JavaScript, but it still gives us a lot! We can use the following features in C to implement similar features in Javascript:

  1. control structures: `if`, `for`, `while` etc will map well between languages
  2. function calls: we can compile JS functions to C functions

  Features that C lacks we'll need to write from scratch, and comprise much of the runtime C library:

  1. garbage collection
  2. exception handling
  3. data-structures: dynamic arrays and objects
  4. prototypal object system

  ## A sketch

  Lets manually walk the following JS code through our compiler tool-chain:

  ```
  function fact(n) {
      return n < 3 ? n : n * fact(n - 1);
  }
  console.log(fact(5));
  ```

  First we run esprima to parse the source and give us a syntax-tree:

  ```
  {
    "type": "Program",
    "body": [
        {
            "type": "FunctionDeclaration",
            "id": {
                "type": "Identifier",
                "name": "fact"
            },
            "params": [
                {
                    "type": "Identifier",
                    "name": "n"
                }
            ],
            "body": {
                "type": "BlockStatement",
  ```
  
  This will be input to `js-to-c.ts`, which would output a target C program. Here's the `fact` function for instance, where you can see the ternary expression being compiled to C control flow:

  ```
  static JsValue *fact_1(Env *env) {
    log_info("User function fact");
    JsValue *return_3;
    /* ternary */
    JsValue *left_6 = (envGet(env, interned_2 /* n */));
    JsValue *right_7 = (jsValueCreateNumber(3));
    JsValue *conditionalPredicate_5 = (LTOperator(left_6, right_7));
    JsValue *conditionalValue_4;
    if (isTruthy(conditionalPredicate_5)) {
      return_3 = (envGet(env, interned_2 /* n */));
    } else {
      JsValue *left_8 = (envGet(env, interned_2 /* n */));
      JsValue *callee_10 = (envGet(env, interned_11 /* fact */));
      JsValue *left_12 = (envGet(env, interned_2 /* n */));
      JsValue *right_13 = (jsValueCreateNumber(1));
      JsValue *call10Arg_0 = (subtractOperator(left_12, right_13));
      JsValue *args_10[] = {call10Arg_0};
      JsValue *right_9 = (functionRunWithArguments(callee_10, args_10, 1, NULL));

      return_3 = (multiplyOperator(left_8, right_9));
    }
    return return_3;
    return getUndefined();
  }
  ```

  More complex behaviour in JS - like function environments - are implemented with our runtime functions, for instance `envGet()`. We couldn't rely on the C call-stack here as JS environments are long lived. Functions are closures and thus their enclosing environment can live well beyond the lifetime of the call-stack that defined them - think of function values stored as global properties or as event-listeners.

  To do this our output programs `#include` (think `require()` or `import` from JS-land) our runtime library's header files[^2], and call the functions that library has defined elsewhere:

  ```
  #include "../../runtime/environments.h"
  #include "../../runtime/exceptions.h"
  #include "../../runtime/functions.h"
  ```

  [^2]: header-files in C define the function prototypes defined elsewhere in `.c` or library files. Relying on the header-files means we can target library code without recompiling.

  In my next post, we'll look at our how our `js-to-c.ts` compiler takes a syntax tree and outputs C source code.
  

  

  
